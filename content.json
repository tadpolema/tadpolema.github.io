{"pages":[],"posts":[{"title":"Typora","text":"Typora语法12345package com.yrp.poimport javax.perpublic class User{ } typora语法 12345678//加粗**等不到天黑**//代码高亮==我是马云骋==//删除线~~this is~~//斜体*斜体* 2.引用1234//引用语法&gt;作者：马云骋&gt;&gt;作者：马云骋&gt;&gt;&gt;作者：马云骋 作者：马云骋 作者：马云骋 作者：马云骋 3.分割线12//分割线---或者*** 4.图片插入12//在线图片/本地图片![我的照片](/image/me.png) 5.超链接12//超链接[我的github](http://...) 8.列表语法123456//无序列表- 目录1- 目录2- 目录3//有序列表1+.+名称 目录1 目录2 目录3 9.表格换回NexT主题直接将yml文件中的theme改成next，再hexo clean /g / s /d就行了","link":"/2020/11/12/Typora/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/12/hello-world/"},{"title":"react","text":"React前言​ 使用 React的原因：react在进行渲染时，相比于原生html和js来说，效率更高，因为其是对单个组件进行重新渲染，而不是刷新整个页面。 1. React安装​ 如果想要针对性的使用 react “全家桶”的某些工具或者库，则需要了解每一个工具的作用和下载方式。不像 jQuery，引用到 html 标签里就可以使用，React的使用需要很多工具的配合。因此，对于初学者来说，上手 React 最简便的方式是使用官网推荐的 React 项目构建工具“create-react-app”，通过使用该工具，即可一步完成所有的配置细节，并安装好需要的依赖。 ​ 使用 React 所必须的环境是：node.js 和 npm ，其中 npm 在安装node.js 时被同步安装，因此只需要安装 node.js 即可。 ​ 安装好 node.js 和 npm 环境之后，打开命令行，输入： 1npm install -g create-react-app ​ 通过这条指令，我们的计算机上安装了 create-react-app 的命令，课用它来进行 React 项目的搭建： 1create-react-app hello-world ​ 等待整个“hello-world”项目安装完成即可。安装完成后，使用命令行进入“hello-world”工程文件夹，使用 1npm start 即可看到效果。 可能遇到的问题 解决方法： ·管理员身份运行 Powershell ·输入set-ExecutionPolicy RemoteSigned，把权限改权限为A ·输入get-ExecutionPolicy，如果此时显示RemotePolicy，即可以正常安装了，重新create即可。 2. JSX​ JSX即一种可以转换为 Javascript 对象的语法，类似于在 Javascript 里面写 html 标签。 ​ DOM元素本身就是一个 Js 对象，包含三个维度的信息：标签类型、属性、子元素，一下引用胡子小书的代码： 12345678910111213141516{ tag: 'div', attrs: { className: 'box', id: 'content'}, children: [ { tag: 'div', arrts: { className: 'title' }, children: ['Hello'] }, { tag: 'button', attrs: null, children: ['Click'] } ]} 以上的 Javascript 对象代码和以下的 Html 代码所表示的信息是一样的： 1234&lt;div class='box' id='content'&gt; &lt;div class='title'&gt;Hello&lt;/div&gt; &lt;button&gt;Click&lt;/button&gt;&lt;/div&gt; ReactDOM.render 的作用就是将 JSX 表示的信息构建出真正的 DOM 元素，并放在页面上进行展示。 因此，React 里的 JSX 经历的转换关系为： ​ JSX -&gt; (Babel编译) -&gt; JavaScript 对象 -&gt; (ReactDom.render) -&gt; DOM 元素 3. Render只要写react.js，就要引入React 和 React.js 的组件父类 Component ，引入以后才能使用 render。使用 render 的时候，必须要返回一个 JSX 元素，有且只有一个，即外层需要有一个 ​ JSX 可以插入 JavaScript 表达式，表达式必须写在 {} 里面： 1234567render(){ return ( &lt;div&gt; &lt;p&gt;this is a {1+1} B boy !&lt;/p&gt; &lt;/div&gt; )} ​ 在 JSX 中不能使用 JavaScript 的关键字给标签加属性，如 class 关键字等，应使用 JSX 的语法，使用如 “className” 等 ​ JSX 的 {} 里面也可以放 JSX ，比如通过条件判断语句，返回不同的 JSX。 123456789101112131415renderFunc(word_ac,word_ne){ const flag = false if (flag){ return word_ne } else{ return wrod_ac }}render(){ return( &lt;div&gt; )} 注：自定义的组件使用大写字母作为开头，以和普通的 html 标签作为区分。 4. 事件逻辑处理4.1 事件监听​ 与传统 JavaScript 语法不同，React 中使用 onXXX 的形式进行事件绑定，如 “ onClick = {this. handleClick} ”，但是 onXXX 事件绑定只能用在普通标签上，不能用在组件标签上。 4.2 setState &amp; state​ 当调用 setState 的时候，状态并不会立即改变，React 的机制会将 state 更改后的对象放在一个队列里，之后才会触发组件的状态刷新。 ​ 如果想要立即使用 setState 后的状态数据，可以使用函数作为参数，如下： 12345678handleClick(){ this.setState((prevState)=&gt;{ return {name:&quot;zhangsan&quot;} }) this.setState((prevState)=&gt;{ return {name:prevState + &quot;'s father&quot;} })} 使用函数作为参数，即可利用上一次 setState 的值进行后续操作。 4.3 props​ 使用原因：使得需要被传入props的组件具有更好的灵活性（通过传入不同的 props ，显示不同的页面或完成不同的响应） ​ props 的传入：在作为标签使用组件的时候把 props 放在标签属性中，props 属性会自动生成键值对对象，不仅能传递字符串、数字、对象、数族，也可以传递函数： 1234567891011class Button extends Component { render () { return ( &lt;div&gt; &lt;GoodButton groups={{Good:'可以', Bad: '不行'}} onClick={() =&gt; console.log('Clicking now!')}/&gt; &lt;/div&gt; ) }} 在 GoodButton 内部即可使用传入的 onClick 函数 defaultProps：默认配置 ​ 对 props 中的各种属性进行初始配置，如果没有 props 传进来，就使用默认 defaultProps ，如果有props 传进来，则使用新传进来的 props 注：props 一旦传进组件就无法改变，即不能: 1this.props.name='balabala' ​ 设计原因是为了保证渲染的确定性，如果传进来的 props 都可以改变，则组件的形态和响应会变得不可预测。 ​ 但仍然存在改变 props 的解决方案：通过主动重新渲染组件的形式，把新的 props 传入组件即可，即，如果想改变子组件的 props，就使用 setState 改变父组件的 state 值，然后再把新的 props 传到子组件里即可。 123456789101112131415161718192021222324252627282930class Fu extends Component{ constructor(){ super() this.state = { atrr1_zi:2, attr2_zi:5, } } handleClick(){ this.setState({ atrr1_zi:4, attr2_zi:10, }) } render(){ return( &lt;div&gt; &lt;Zi attr1_zi={this.state.attr1_zi} attr2_zi={this.state.attr2_zi}/&gt; &lt;div&gt; &lt;button onClick = {this.handleClick.bind(this)}&gt; 修改子组件的 props 属性值 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) }} 5. 渲染列表数据​ 由于 JSX 里面可以放任何形式的表达式，因此也可以放存放 JSX 的数组，如： 1234567891011render(){ return( &lt;div&gt; {[ &lt;span&gt;a &lt;/span&gt; &lt;span&gt;b &lt;/span&gt; &lt;span&gt;c &lt;/span&gt; ]} &lt;/div&gt; )} 但这种方法进行渲染代码编写量大，最好还是使用循环或者其他方法进行列表数据的渲染，因此。解决方法如下： （1）循环渲染 123456789101112131415161718192021222324const names = [ {name:'xiao ma'}, {name:'xiao li'}, {name:'xiao yang'}]class Boys extends Component{ render(){ const nameArrays = [] for (let name of names){ nameArrays.push( &lt;div&gt; &lt;div&gt;姓名:{names.name}&lt;/div&gt; &lt;/div&gt; ) } return( &lt;div&gt;{nameArrays}&lt;/div&gt; ) }}ReactDOM.render( &lt;Boys /&gt;, document.getElementById('root')) （2）map渲染 123456789101112131415class Boys extends Component{ render(){ return( &lt;div&gt; {names.map((name)=&gt;{ return( &lt;div&gt; &lt;div&gt;姓名：{name.name}&lt;/div&gt; &lt;/div&gt; ) })} &lt;/div&gt; ) }} 6. 状态提升​ 把某组件与其他组件需要进行共享的状态 state ，存放在距离他们最近的公共父节点进行存储，然后通过 props 向子组件进行状态的传递。 ​ 当某个状态被多个组件依赖（显示同样的数据或者相关数据）或者影响（状态随着其他组件的改变而改变）的时候，要进行状态提升。​ 7. 挂载（看作initial，从无到有）​ 挂载：React.js 对组件进行渲染，并构造相应的 DOM 元素并把它加载到页面 。 注：setState 只能在已经挂载或者正在挂载的组件上进行调用，否则会报错。 8. 更新（看作change，1–&gt;anything）​ 通过 setState 导致 React.js 需要重新渲染 9. ref 和 React.js 中的 DOM 操作​ react.js 提供了一系列 onXXX 函数用来处理事件监听，所以不需要手动调用 DOM 的 API ，原本对 DOM 进行操作时需要对 DOM 本身进行操作，例如调用 jQuery 进行事件监听或者页面的重新渲染等。但 React.js 并不能满足所有的 DOM 操作，所以仍需要对 DOM 进行操作，即使用 ref 属性进行挂载 ​ 附：this 和 e.target 的区别： ​ js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素。this 和 e.target 都是DOM对象。 ​ React 中的方法，不是通过调用对象的方法来运行的，而是直接通过函数名，因此，如果再调用函数时，函数内部需要使用到 this，则获取不到当前组件。解决方法：再调用函数时使用 bind (this) 将函数0。和组件绑定，即可访问到 this 组件。 ​","link":"/2020/11/13/react/"},{"title":"空间计量学","text":"1. 三种常见矩阵邻接矩阵，反距离矩阵，地理距离矩阵，嵌套矩阵 2. 空间溢出：产业集聚是否对周围地区产生一定的影响 全局莫兰，局部莫兰（LISA聚类图） 3. 空间杜宾模型重点：普通线性回归模型 OLS、空间误差模型 SEM、空间滞后模型 SLM 都是由一个方程得到的：$$y = ρW1y + βx + ε$$ $$ε=λW2ε+μ$$ ​ 这个模型叫做 广义空间回归模型 SAC ，即混合了空间误差模型和空间滞后模型的模型。 ​ 通过改变不同变量的系数，来得到不同的模型公式。其中，y代表因变量，x为自变量，W代表空间权重矩阵。 （1）OLS：普通线性回归模型 ​ 表示单纯的线性数量关系，可以理解为线性方程y=ax+b，由于 OLS 不考虑邻近空间单元的影响，因此 ρ 和 λ 均为 0，所以$$y = βx + μ$$（2）SEM：空间误差模型 ​ 只考虑空间上的随机干扰项在空间上的相关性，因此 λ ≠ 0，ρ = 0：$$y = βx + ε$$ $$ε=λW2ε+μ$$ （3）SLM：空间滞后模型 ​ 空间滞后效应指：因变量，或被解释变量，受到周围空间单元的其他变量的影响，即 ρ ≠ 0，λ = 0：$$y = ρW1y + βx + μ$$（4）SDM：空间杜宾模型 ​ 思考：就算是广义空间回归模型，仍没有考虑时间上的滞后，在计量学中，“滞后”的原义便是指时间上的滞后，即变量受先前时期变量的影响。 泊松分布：单位时间或单位面积内随机事件的平均发生次数 4. CA 和 ABM​ CA 和 ABM：前者全局性，后者局部性。全局规则，不易改变；局部规则较为灵活，但计算量大","link":"/2020/11/23/%E7%A9%BA%E9%97%B4%E8%AE%A1%E9%87%8F%E5%AD%A6/"}],"tags":[],"categories":[]}